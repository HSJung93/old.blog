---
title: "비동기/ 병렬 처리와 파이썬에서의 코루틴, FastAPI"
date: 2021-09-14T14:19:00+09:00
categories:
  - 코드
tag:
  - await/ async
  - 비동기성
  - FastAPI
  - 코루틴
header:
  teaser: /assets/images/code.jpg
toc: true
toc_sticky: true
---

FastAPI이라는 웹 프레임워크가 주목받아 튜토리얼을 진행하다 보니, 함수 앞의 `async`와 라이브러리를 선언하기 전에 `await`이 눈에 띕니다. FastAPI 프로젝트를 진행 중에 `await`으로 선언하라는 라이브러리를 발견했다면 어떻게 해야할까요? 결론부터 이야기하자면 해당 라이브러리를 선언할, path operation(end point, url)함수 앞에도 `async`를 붙이시면 됩니다. 

왜 그럴까요? 서론부터 설명하자면 깁니다. 이제 파이썬에서 어떻게 비동기 프로그래밍을 할 수 있는지 정리할 좋은 기회가 온 것 같습니다. 

## 비동기 코드
는 해당 언어가 코드의 특정 지점에서 컴퓨터 프로그램에게 코드를 끝마치기 위해서 **무엇**인가를 기다려야 한다고 알리는 방법을 가지고 있음을 의미합니다. 그 **무엇**인가를 **느린파일**이라고 합시다. 그러면 느린파일을 기다리는 동안 컴퓨터는 다른 곳에 가 다른 일을 할 수 있습니다. 다른 일을 하는 도중이나, 다른 일을 완료했을 때 컴퓨터 프로그램은 중단되었던 그 지점으로 종종 돌아옵니다. 그리고 기다림이 끝나면 다시 우선순위가 높은 작업을 합니다. 

보통 코드는 프로세서나 램 메모리에 비하여 상대적으로 느린 I/O 작업을 기다리곤 합니다. 예를 들면, 클라이언트로부터의 데이터가 네트워크를 통하여 보내지길 기다린다던가, 우리의 프로그램으로부터 보내진 데이터를 네트워크를 통하여 클라이언트에게 도달하는 것을 기다린다던가, 디스크의 파일내용이 시스템에게 읽어지고 프로그램에 주어질 때까지 기다린다던가, 우리의 프로그램이 시스템에게 준 내용이 디스크에게 읽어질 때까지 기다린다던가, 원격 API 작업을 기다린다던가, 데이터베이스 작업이 끝나길 기다린다던가, 데이터베이스 쿼리가 결과를 리턴하기가지 기다립니다.  

## 비동기성 vs 병렬성
이런 I/O bound 작업은 비동기적이라고 이야기합니다. 컴퓨터나 프로그램이 느린 작업과 동기적(혹은 연쇄적)이 될 필요가 없기 때문입니다. 다시 말해, 느린 작업이 끝나는 그 순간 까지 기다리면서 아무것도 안할 필요가 없습니다. 비동기적인 코드는 동시성이라고도 불리지만 **병렬성과는 전혀 다릅니다.** 둘 다 서로 다른 작업들이 거의 같은 시간에 일어난다는 의미에서 유사하지만 세밀하게는 다릅니다.

동기적인 작업과 병렬적인 작업을 햄버거 가게에 가서 당신과 친구가 주문하는 상황에 비유해봅시다. 동기적인 작업 상황에서는 예컨대, 당신은 판매대 직원에게 햄버거를 주문을 하고나면 자리로 돌아와 당신의 친구와 잡담을 할 수 있습니다. 주문하고 햄버거를 받을 때까지 판매대에서 기다릴 필요가 없이, 친구와 잡담을 하면서 기다리다가, 주문이 완료되었다는 벨이 울리고 친구와 잡담이 마무리되면 가서 햄버거를 받아오면 됩니다. 아무도 당신 번호표의 햄버거를 가져가지 않습니다. 햄버거 주문과 친구와의 잡담은 비동기적입니다. 반면 병렬적인 작업은 동기적일 수 있습니다. 예컨대 판매대가 8개인 햄버거 가게에 당신과 친구가 각각 판매대에서 주문한 뒤 햄버거를 기다리고 있는 상황이 이와 같습니다. 당신과 친구는 주문을 하고 기다리는 동안 새치기를 못하도록 자리 잡고 있느라 잡담을 나눌 수 없습니다.

웹 어플리케이션의 경우에는 비동기적인 처리가 중요하지만, 비동기적인 처리가 병렬적인 처리보다 완전히 우선순위에 있는 것은 아닙니다. 대기할 필요 없이 CPU을 사용해야할 일이 많을 때는 병렬적인 처리가 중요합니다. 이런 CPU bound한 작업들에는 복잡한 수리적인 프로세스들이 해당합니다. 오디오나 이미지 작업, 수백만의 픽셀에 3가지 색상을 동시에 부여해야하는 컴퓨터 비전 작업, 고차원의 매트릭스나 벡터곱이 동시적으로 처리되어야 하는 머신러닝이나 딥러닝이 이에 해당합니다. 

## 파이썬은
인터프리터 언어로서, 한 스레드만 하나의 바이트 코드를 실행시킬 수 있도록 GIL이 되어있습니다. 하나의 스레드에 모든 자원을 허락하고 그 후에는 락을 걸어 다른 스레드는 막아버리는 것입니다. 따라서 병렬 처리를 하기 위해서는 별도의 모듈을 사용하여 구현하곤 합니다. 그런데 FastAPI에 비하여 Flask와 Django(비록 비동기 처리는 웹소켓을 지원하려는 Django에서 발전하기는 했지만)와 같은 파이썬 프레임워크에 적용된 병렬 처리와 비동기 처리는 다소 옛날 방식이라고 합니다. threads 나 Gevent가 이에 해당합니다. 비동기 처리는 NodeJS를 주목받게 해주었고(단, NodeJS는 병렬처리를 지원하지는 않습니다), Go의 프로그래밍 언어로서의 힘을 보여주기도 합니다. FastAPI는 병렬처리와 비동기처리를 동시에 구현하면서 NodeJS 프레임워크보다 낫고 Go와 유사한 성능을 보여주고 있다고 합니다. 

## `async` 과 `await`
다시 `async` 과 `await`을 돌아옵시다. 특정 작업 전에 `await`를 붙여주면 컴퓨터는 그 함수가 완료되기 까지 기다려야한다는 사실을 알고 다른 작업을 합니다. 

```python
burgers = await get_burgers(2)
```

그리고 `await`하기 위해서는 그 함수는 `async def`로 함수가 선언되어 있어야 한다. 그러면 컴퓨터는 다른 작업을 수행하기 위해서 이 함수를 잠시 멈출 수 있음을 알게됩니다.  

```python
async def get_burgers(number: int):

    # Do some asynchronous stuff to create the burgers
    return burgers
```

결론적으로 이 포스팅의 처음에 언급했던 것처럼, `await`을 선언하라는 라이브러리를 사용한다면, path operation 함수에서도 `async def`를 사용해야합니다. path operation 함수안에 `await`해야 하는 `async def` 선언된 함수가 존재한다는 뜻이니까요!

```python
@app.get('/burgers')

async def read_burgers():

    burgers = await get_burgers(2)

    return burgers
```

여기까지의 설명에 따르면 `await`은 `async def`로 정의된 함수 안에서만 사용되어야 하는 동시에, `async def`로 정의된 함수는 "awaited" 되어야하기에 `async def`로 정의된 함수 안에 존재해야합니다. 그렇다면 최초의 `async`함수는 어떻게 불러와야 할까요? FastAPI는 path operation function이 최초의 `async` 함수가 되도록 해줍니다. FastAPI 바깥에서는? 코루틴을 다루는 [파이썬의 공식문서][https://docs.python.org/3/library/asyncio-task.html#coroutine]를 확인해봅시다. 

## 코루틴
이란 `async def` 함수로 리턴되는 것들을 세련되게 요약하여 표현한 것입니다. 코루틴은 내부에 `await`이 존재할 때, 실행 이후에 내부적으로 정지되었다가 종료되는 함수의 하나입니다. 최신 파이썬은 `async`과 `await`이라는 문법으로 코루틴이라고 불리우는 비동기적인 코드를 지원합니다.

## 참조
* [FastAPI 튜토리얼][FastAPI-tutorial]
* [GIL은 무엇일까?][what-is-gil]
* [멀티스레드와 멀티프로세스][multi-thread-process]

[FastAPI-tutorial]: [https://fastapi.tiangolo.com/async/#in-a-hurry]
[what-is-gil]: [https://ssungkang.tistory.com/entry/python-GIL-Global-interpreter-Lock%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C]
[multi-thread-process]: [https://monkey3199.github.io/develop/python/2018/12/04/python-pararrel.html]