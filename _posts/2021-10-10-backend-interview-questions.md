---
title: "백엔드 기술 면접 대비 질문 리스트"
date: 2021-10-10T17:15:00+09:00
categories:
  - 메모
tags:
  - 백엔드
  - 빅데이터
  - 면접
header:
  teaser: /assets/images/slipBox.jpg
toc: true
toc_sticky: true
---

기술 면접을 대비하며 공부한 내용들입니다. 실제로 면접을 봐보니 전부 다 외우는 것이 중요한 것 같지는 않았습니다만, 개발자가 되기에 앞서서 한번은 필요한 작업이었다는 생각이 듭니다.

## 자바

1. JVM이란?.
   1. JVM은 운영체제 위에서 동작하여 자바 언어로 작성된 프로그램이 실행되도록 하는 가상 머신입니다.
   2. 자바로 작성된 프로그램이 실행되면 JVM은 운영체제로부터 필요한 메모리를 할당받고, 용도에 따라서 여러 영역으로 나누어 관리합니다. 자바 컴파일러인 javac가 자바 소스코드를 읽어들여서 바이트 코드(class 파일)로 변환시키면, class loader가 class 파일들을 JVM으로 로딩합니다. 이후 JVM은 이처럼 바이트 코드를 CPU가 처리할 수 있는 기계어로 번역시키는 역할을 합니다.
   3. 이러한 실행의 과정에서 JVM의 주요 역할 중에 하나가 GC 가비지 컬렉팅나 스레드 싱크로나이즈 입니다.
2. 컴포넌트와 모듈의 차이는?
   1. 컴포넌트는 실제 동작하고 있는 개체, 모듈은 실질적으로 구현이 된 단위
   2. 서버 클라이언트 구조에서 서버 1개에 클라이언트 100대가 있다면 구현된 모듈은 서버1 클라이언트 1 총 2개, 컴포넌트는 서버 1개 클라이언트 100개 총 101개
3. HashMap이란?
   1. 키와 값으로 구성된 구조를 가지는 컬렉션의 클래스이다.
   2. Map 인터페이스를 상속받은 구현체로, 다른 Map 인터페이스의 구현체로는 treeMap이 존재하는데, 이진 검색 트리의 형태로 데이터를 저장한다.
   3. 객체가 가지고 있는 hashcode값에 따라서 key 테이블이 위치할 곳으로 정한다.
4. 런타임 vs 컴파일 타임
   1. 런타임: 컴파일 과정을 마친 프로그램이 사용자에 의해 실행될 때의 환경 또는 시간이다
   2. 런타임 에러: 0 나누기 오류, 널 참조 오류, 메모리 부족 오류
   3. 컴파일: 사람이 이해할 수 있는 고수준의 언어를 기계어로 번역하는 것
   4. 컴파일 타임: 프로그램을 위한 소스코드를 작성하고 컴파일하여 기계어 코드로 변환하는 과정 혹은 시간
   5. 컴파일 에러: 신텍스 에러, 타입 체크 에러, 문법 참조 오류
5. 스트링 버퍼 클래스 vs 스트링 클래스
   1. 가변 클래스인 스트링 버퍼 인스턴스에 append()로 값을 더해줘도 같은 인스턴스이다.
   2. 자기 자신을 리턴하는 것을 이용해서 메소드 체이닝을 사용할 수 있다.
   3. 불변 클래스인 스트링 인스턴스에 + 연산을 하면 스트링 버퍼 객체를 만들고 append()로 만들어서 리턴하는 것이다.
   4. 따라서 반복문에서 사용하면 스트링 버퍼 객체를 여러번 new로 생성해야 해서 느려진다.
   5. 그래서 불변 클래스인 스트링 클래스는 계속 생성하기에 느린 단점을 가지고 있다.
6. 컬렉션 프레임워크는 자료구조 클래스들이다.
   1. 컬렉션 인터페이스는 add, iterator, size 메소드가 있다.
   2. Set 중복을 허용하지 않는다
   3. List 중복을 허용하면서 순서를 기억한다
   4. Map은 키와 밸류를 가지고 있다. put, keySet, put 등
   5. 이 세 인터페이스를 구현한 ArrayList, HashSet, HashMap이 존재한다.
7. 어노테이션: 클래스나 메소드 위에 붙여서 소스코드에 메타코드를 주는 것
   1. @interface 로 선언하고, @Retention()을 어노테이션으로 단다.
8. 제너릭이란? 클래스 생성 시에 필드의 타입을 사전적으로 제한하는 것
   1. 클래스 뒤 <> 표시에 E를 적고 타입들을 E로 바꾸어 주면 된다.
   2. Method 타입으로 .getClass().getDeclaredMethod(“hello”) 로 클래스의 정보와 hello란 이름의 메서드에 정보를 가져올 수 있다.
   3. .isAnnotationPresent()로 어노테이션 적용을 확인할 수 있다.
9. 바이트 단위 입출력 클래스?
   1. inputStream, outputStream이라는 추상클래스를 상속 받아서 만들어진다.
   2. 파일로부터 한 바이트 씩 읽어들여서 한 바이트씩 저장하는 클래스이다.
   3. FileInputStream의 read()메소드는 int 타입이며 값이 없으면 -1을 리턴한다. FileOutputStream의 write(readData)로 저장한다.
   4. close() 메소드로 닫아주어야 한다.
   5. byte[] 객체를 buffer로 선언하고 read(buffer), write(buffer, 0, readCount)로 저장한다. 운영체제가 보통 512바이트 씩 읽으므로 512 바이트로 읽는 것이 효율적이다.
10. 데코레이터 패턴:
    1. 하나의 클래스를 장식하는 것처럼 생성자에 감싸서 새로운 기능을 계속 추가할 수 있도록 클래스를 만든다.
    2. 서브 클래스를 만드는 것을 통해 기능을 유연하게 확장할 수 있다.
    3. 자바 I/O가 데코레이터 패턴으로 만들어져 있다.
11. 다양한 입출력
    1. DataInputStream, DataOutputStream의 생성자는 OutputStream의 자손을 모두 매개변수로 받아들인다.
    2. 즉 장식의 역할을 한다 = 다양한 메소드를 제공한다.
    3. BufferedReader, PrintWriter도 장식하는 클래스인데, Reader와 Writer의 자손을 받는다.
    4. 4가지 클래스를 받아들이는 생성자가 있다면 다양한 입출력을 받는 클래스이다.
12. Char 단위 입출력
    1. Reader, Writer 추상 클래스를 상속 받아서 만들어진다.
13. 자바 Time 관련 함수
    1. Calendar: 추상 클래스이다. new로 인스턴스를 생성할 수 없고, 자기자신을 만들어서 리턴할 수 없어서, getInstance() 로 자식 클래스의 인스턴스를 리턴한다.
14. 자바 스레드
    1. MyThread 클래스는 Thread 객체를 상속하거나 Runnable 인터페이스를 구현하여 만든다. run() 메소드를 오버라이딩 한다.
    2. 이 클래스를 new 생성자로 만들고, start()로 실행한다. 이 때 Main 흐름과 run을 사용하는 Thread의 흐름이 나뉜다.
    3. Runnable을 사용한 경우, Thread 생성자로 데코레이트 해서 사용해야 한다.
    4. 서비스하는 클래스를 만들고 -> MyThread의 run()안에서 사용한 뒤 -> 실행하는 클래스를 여럿 만들어서 start()로 실행한다.
15. 자바 동기화
    1. 서비스하는 클래스의 메소드에 synchronized를 선언하면, 스레드가 이 공유 객체를 사용할 때 먼저 사용하면 사용권을 얻는다.
    2. 모니터링 락: 한 스레드의 공유 객체 선점 사용권. wait를 만날 때 까지 락을 건다.
    3. 메소드 말고 일부분에 싱크로나이즈드 블록을 걸어줄 수 있다. synchronized (this) {} 한 뒤, {} 안에 넣는다.
16. 쓰레드와 상태제어
    1. 스레드는 실행되었다가 대기 상태에 있다가 다시 실행되는 것을 반복한다.
    2. 스레드가 실행되면 어떤 상태가 되나요? 러너블 상태와 러닝 상태가 됩니다!
    3. wait()으로 블록 상태에 들어가고 notify()로 나온다. sleep으로 들어가면 일정 시간 후에 나온다.
       1. 동기화된 블록 안에서 사용하는 메서드이다.
       2. ThreadB를 생성하고 run 메서드 안에 동기화된 블록을 생성한다. 이후 이를 깨우는 notify() 메서드를 사용한다.
       3. 메인에서 ThreadB를 생성, start()한다. 해당 스레드는 run() 안에서 자신의 모니터링 락을 획득할 것이다. 메인에서 ThreadB에 동기화된 블록을 하나 더 생성한다.
       4. 이 안에서 ThreadB의 wait() 메서드를 사용하면 메인 스레드는 정지하고 b에서 notify()를 만날 때 깨어난다.
       5. wait()가 실행되면 모니터링 락을 놓고 대기한다.
    4. yield()로 스레드가 자원을 양보한다. 다른 스레드가 좀 더 빨리 사용되게 한다.
    5. join() 메소드로 해당 스레드가 종료할 때까지 대기한다.
       1. 예를 들어 main에서 스레드를 생성하고 start()하고 도중에 join() 메소드를 실행하면, main 스레드가 생성된 스레드가 끝날때까지 기다린다.
17. 람다 표현식 = 익명 메서드: 자바는 메서드만 전달하는 방법이 없어서, 객체로 생성해서 전달해야한다. 이를 람다 표현식으로 해결할 수 있다.

## 스프링

1. 스프링 프레임워크를 사용한 이유?
   1. 자바 언어를 바탕으로 자바 언어의 객체 지향적인 장점을 잘 활용한다.
   2. 또한 IoC와 DI로 빠른 속도와 안정성을 제공한다.
      1. IoC: 제어의 역전: 메소드나 객체의 호출작업을 개발자가 결정하는 것이 아니라 외부에서 결정하는 것. new 가 아니라
      2. DI: 의존성 주입: 의존적인 객체를 직접 생성해서 제어하는 것이 아니라 특정한 객체 필요한 객체를 외부에서 결정해서 연결 시키는 것.
   3. 스프링 MVC에 비하여 직접 작성할 것이 적고, 스프링 부트에 initialize를 사용할 경우 편리하게 의존성 관리 등을 진행할 수 있다.
   4. 국내에서 대다수가 사용하고 있어서, 안정성이 높고, 레퍼런스를 찾고 공부하기 쉬웠다.
2. 스프링 부트의 장점?
   1. 의존성 버전 관리가 편리하다.
      1. 버전을 -starter-로 입력가능
      2. 설정도 WEB-INF/jsp가 아니라 application.properties나 yml 파일로 작성할 수 있다.
   2. 내장 서버로 배포 서버를 간단히 구축할 수 있다.
      1. 구동 시간이 단축된 내장 서버
      2. 내장 서블릿 컨테이너 덕분에 jar 파일로 빌드 후 간단 배포가 가능합니다.
   3. 스프링 시큐리티, 스프링 JDBC 등 스프링 프레임워크의 요소들을 조금 더 간편히 사용한다.
   4. 인터넷에 공식 문서를 잘 활용할 수 있다.
3. TDD란? 왜 해야 하는가? 프로젝트에서 어떻게 했는가?
   1. 테스트 주도 개발: 테스트 코드를 먼저 짜고 그 이후에 코드를 짜는 방법
   2. 요구사항 파악 -> 레드: 실패하는 테스트 코드 작성 -> 그린: 구현 -> 리팩토링을 순환한다.
   3. 왜? 급변하는 예측 불가능한 상황에 대처(리팩토링) 용이. 테스트 커버리지가 높아짐(미루지 않는다). 오버 엔지니어링 방지. 설계에 대한 피드백이 빠르다.
   4. vs 워터폴 모델: 요구사항 파악, 설계 및 구현, 시험, 통합 및 유지 보수를 순차적으로 따르는 소프트웨어 개발 프로세스. 각 단계를 완벽히 마무리한 후 다음 단계를 진행하는 것이 불가능하다.
4. 단위 테스트란
   1. 단위 테스트란 일반적으로 메서드 레벨의 가장 작은 단위의 테스트. TDD의 첫번째인 기능 단위의 테스트 코드 작성
   2. 전체 테스트는 인수(고객 대리인), 부하(요청/단위 시간), 기능(api바깥 코드 검사, 컨트롤러, 시큐리티 등), 통합(객체 간, 서비스 간 워크 플로우), 단위 로 구성
   3. 왜? 과도한 설계를 피하고 간결성 증대. 테스트 코드 자체가 동작하는 문서 역할을 한다. 독립된 코드 작성으로 의존성 관리가 편함.
   4. Fast, Independent, Repeatable, Self-Validating, Timely
5. JUnit
   1. 자바의 유닛 테스트 프레임워크
   2. 버전 5까지
   3. src 밖에 별도로 test 디렉토리를 만든 뒤에 관련된 라이브러리를 import 문법에 맞게 코드와 어노테이션을 작성한 뒤 수행한다.
6. 스프링 웹 계층

   1. 웹 계층: 뷰 템플릿 영역
      1. 컨트롤러, 필터, JSP, 인터셉터
      2. JSP: html 속 자바 소스 코드가 들어간 파일 형식
      3. 외부 API 요청과 응답에 대한 처리
      4. Controller는 사용자의 요청을 처리한 후 지정된 뷰에 모델 객체를 넘긴다.
      5. 뷰를 연결하여 웹에 띄우고 뷰에서 가져오는 데이터들을 역할에 맞춰 사용자의 요청을 처리한다.
   2. DTO
      1. 요청 데이터를 받는다.
      2. 계층 간의 데이터 교환을 위한 객체
      3. 뷰 템플릿 엔진에서 사용될 객체나, 레포지토리 층에서 결과로 넘겨준 객체 타입
      4. Entity를 컨트롤러에 직접 전달하는 대신 DTO를 사용해서 교환
   3. 서비스 계층
      1. @Service 와 @Transactional 사용
      2. 트랜잭션, 도메인 기능 간의 순서를 보장한다.
      3. 서비스에서 비지니스 로직을 처리해야한다는 오해?
      4. Model이 db에서 받아온 데이터를 전달 받아 가공하여 view에게 제공한다. 혹은 반대로 컨트롤러에서 받은 요청 사항에 맞게 데이터를 가공해서 db에 전달한다.
   4. Domain Model
      1. 개발 대상을 모든 사람이 동일한 관점에서 이해하고 공유하도록 단순화시킨 것
      2. @Entity(DB 테이블과 1대1 대응되며 테이블에 존재하는 컬럼들을 필드로 가지는 객체)가 사용되는 영역
         1. Entity를 변경하면 DB에 값이 반영되기 때문에, DTO를 따로 두어서 데이터 변경에 대응
      3. 무조건 데이터베이스와 테이블과 관련 있는 것은 아니고, VO(읽기만 가능한 DTO) 처럼 값 객체들도 이 영역에 해당
      4. 도메인에서 비지니스를 처리한다.
      5. Model은 db에서 값을 가져와 도메인 오브젝트에 리턴 시키거나, 반대로 도메인의 값을 가져와 db에 리턴한다.
      6. db의 받고자 하는 값과 타입을 클래스의 필드로 적는다.
      7. 롬복의 도움으로 세터를 생략한다.
   5. 레포지토리 계층 = DAO
      1. 실제로 DB에 접근하는 객체이다. 서비스 모델과 DB를 연결한다.
      2. JPA에서는 DB에 데이터를 CRUD하는 Repository 인터페이스들이 DAO다. `JpaRepository<entity 클래스, pk 타입>`를 레포지토리에 상속
      3. 기본적으로 CRUD가 자동으로 생성된다. 복잡한 쿼리 없이 CRUD 명령을 db에 전달한다.

7. Spring Data JPA
   1. ORM: SQL 쿼리가 아니라 매서드로 데이터를 조작하도록 한다. 객체간 관계를 바탕으로 SQL을 자동으로 생성한다.
   2. JPA: 인터페이스. JPA는 자바 ORM 기술에 대한 표준 인터페이스로 JAVA에서 제공한다. 애플리케이션과 JDBC 사이에서 동작한다. JPA 내부에서 JDBC API를 사용한다.
      1. DAO 에서 Entity를 JPA로 넘기면, JPA는 이를 분석해서 SQL문을 생성하고 JDBC API를 사용하여 DB에 날린다.
      2. 객체 중심적인 개발이 가능하기 때문에 사용해야 한다.
      3. 영속 컨텍스트 = 엔티티를 영구 저장하는 환경. 엔티티가 영속 컨텍스트에 포함되면, 트랜잭션이 끝나는 시점에 해당 테이블에 변경분을 반영한다.
   3. Hibernate: 구현체
   4. Spring Data JPA: 구현체들을 추상화시킨 모듈. 스프링에서 제공하는 프레임워크다.
8. ORM
   1. 객체(클래스)와 관계형 데이터베이스(테이블)의 데이터를 자동으로 매핑해주는 것
   2. 장점: SQL 쿼리가 아니라 직관적인 메서드로 데이터를 조작할 수 있어 객체 모델로 프로그래밍하는데 집중할 수 있도록 한다. DBMS에 덜 종속. 재사용 및 유지 보수가 편리하다. 객체들을 재활용할 수 있고 모델에서 가공된 데이터를 컨트롤러에 의해 뷰와 합쳐지는 형태로 디자인 패턴을 다질 수 있다.
   3. 단점: 프로시저가 많으면 다시 객체로 바꾸는 과정에서 생산성 저하가 나타난다. 프로젝트가 복잡할수록 난이도가 올라간다. 대형 쿼리는 속도를 위해 튜닝이 필요하다.
9. 트랜잭션
   1. 데이터베이스의 상태를 변경하는 작업 또는 한번에 수행되어야 하는 작업. @Transactional을 Service의 메서드에서 사용한다.
   2. 서비스는 트랜잭션과 도메인간 순서 보장의 역할만 한다.
   3. begin, commit, rollback 수행
   4. 원자성, 일관성, 격리성, 영속성.
10. 더티체킹
    1. JPA 엔티티 매니저의 메서드에는 수정에 해당하는 메서드가 없다. 대신 더티체킹을 제공한다.
    2. JPA에서는 Transaction 안에서 엔티티의 변경이 일어나면, 변경 내용을 자동으로 데이터베이스에 반영하는데 이를 더티체킹이라고 한다.
11. 머스테치 vs 타임리프
    1. 서버 사이드 템플릿 엔진 vs 클라이언트 템플릿 엔진: 브라우저 위에서 작동. 자바 스크립트 코드가 브라우저에서 작동. 서버에서 JSon 혹은 xml 형식의 데이터만 전달하고 클라이언트에서 조립.
    2. 타임리프: 스프링 공식이다. 기능이 많다. 문법이 어렵다. 태그에 속성으로 템플릿 기능을 사용한다. vscode에서 문법체크를 한다.
    3. 머스테치: 화면의 역할에 충실하다. 로직 코드를 사용할 수 없어 View의 역할과 서버의 역할이 명확하게 분리된다. 커뮤니티 버전에서도 설치 가능한 플러그인이 존재한다.
    4. src/main/resources/templates
12. 쿼리dsl
    1. 규모가 있는 프로젝트에서 데이터 조회는 FK의 조인, 복잡한 조건 등으로 인해 entity 클래스만으로는 처리하기 어려워 조회용 프레임워크를 추가로 사용한다. 쿼리dsl, jooq, MyBatis가 대표적이다.
    2. 쿼리 dsl의 장점: 1. 타입 안정성이 보장된다. 메소드를 기반으로 쿼리를 생성하기 때문에 IDE에서 오타나 오류를 검출한다. 2. 레퍼런스가 많다.
13. 스프링 시큐리티
    1. 스프링 시큐리티: 스프링 기반의 애플리케이션에서 보안을 위한 표준 프레임워크.
    2. 도메인에서 사용자 정보를 담당할 User 클래스, 사용자의 권한을 관리할 role Enum 클래스, User의 CRUD를 책임질 UserRepository 생성 이후에 /config.auth에 작성
    3. 스프링 시큐리티에서는 하위 필드를 명시할 수 없는데, 네이버의 응답값 최상위 필드는 resultCode, message, response이다. 본문에서 담고 있는 user_name을 response로 지정한 뒤, 자바 코드로 response의 id를 user_name으로 지정한다.
14. OAuth2
    1. 스프링 부트 2.0에서 바뀐 점: 1. url주소 명시할 필요 없이 클라이언트 인증 정보만 2. Enum으로 설정.
    2. 구글 클라우드 플랫폼에서 OAuth 클라이언트 키 발급
    3. application-oauth.properties에 설정
15. WAS란? 웹서버와 다양한 기능을 구현할 수 있는 컨테이너를 결합한 것.
    1. 클라이언트로부터 동적인 컨텐츠에 대한 요청이 오면 웹서버가 컨테이너로 http요청을 보낸다.
    2. 웹 서버와 연동하여 실행할 수 있는 자바 환경을 제공하는 대표적인 WAS가 톰캣이다.
16. 서블릿: 서블릿은 html 태그를 문자열로 처리하는 자바 프로그램이다.
    1. 컨테이너는 서블릿을 통하여 동적인 컨텐츠 요청을 해결한다.
    2. HttpServlet 클래스를 상속받아서 구현하고, Request와 Response 객체를 생성한다. 이 과정에서 url과 서블릿을 매핑해둔 xml 파일을 참조한다.
    3. 이후 해당 서블릿 파일에서 service 메소드를 호출하고 doGet()이나 doPost()로 동적 페이지를 생성한 후, Response 객체에 응답을 보낸다.
    4. 문제점: out.println() 메소드로 웹페이지를 문자열로 만들어야 한다.
17. JSP: html 소스 코드 속에 자바 소스 코드가 들어간 파일.
    1. <%%> 혹은 <%==%>로 처리한다.
    2. 장점: 컴파일과 같은 작업 없이 웹 서버의 디렉토리에 추가하는 등 간단히 자바 소스 코드를 수정할 수 있다.
18. MVC 모델:
    1. 뷰: 화면을 출력한다.
    2. 컨트롤러: 요청과 응답의 흐름을 제어한다.
    3. 모델: 비지니스 로직을 수행한다.

## 빅데이터 관련

1. 카프카: 실시간 처리를 위한 분산 메시징 시스템. 분산 스트리밍 플랫폼.
   1. 소스 어플리케이션은 카프카에 데이터를 보내고, 타겟 어플리케이션은 카프카로부터 데이터를 받는다.
   2. 카프카에는 토픽이라는 큐(스트림)가 있어 프로듀서는 데이터를 넣고, 컨슈머는 데이터를 가져간다.
      1. 토픽: 여러 파티션으로 구성되어 있다. 컨슈머는 데이터를 오래된 순으로 가져간다. 파티션을 늘릴 수는 있지만 줄일 수 는 없다. 데이터를 가져가도 사라지지 않는다.
      2. 프로듀서: 특정 토픽에 해당하는 메시지를 직렬화하여 생성하고 publish한다. 브로커로 전송한다.
      3. 컨슈머: offset을 커밋하고 병렬적으로 폴링한다.
   3. 스프링 카프카에서는 @KafkaListener()로 topic을 지정하면, ConsumerRecord<?, ?> record 파라매터러 받을 수 있다.
   4. 단점: 스레드를 점유하기 때문에, 한 시점에서는 스레드 하나에서는 하나의 레코드만 처리할 수 있다. 처리하는 시간이 길어지면 병목이 일어난다.
   5. 해결책: 파티션을 분배하여 병렬적으로 처리(동시적으로 준 것은 아니다)한다.
2. 카프카-스트림: 카프카에 저장된 데이터를 처리하고 분석하기 위해 개발된 클라이언트 라이브러리.
3. 하둡: 대량의 자료를 처리하기 위한 분산 처리 시스템

   1. 하둡 파일 시스템(HDFS): 대규모 데이터를 관리하기 위한 분산 파일 시스템. 저장하고자 하는 파일을 블록 단위로 나누어서 분산된 서버에 저장한다.
      1. 네임노드: 전체 HDFS의 네임스페이스를 관리한다. 계속 실행되어야 한다.
      2. 데이터노드: 물리적으로 로컬 파일 시스템에 HDFS 데이터를 저장한다.
   2. 맵리듀스:

      1. HDFS에 분산 저장되어 있는 데이터를 병렬로 처리하여 취합한다.
      2. 맵과 리듀스 함수를 이용하여 데이터 단계별로 처리하고 실행한다.

   3. 하이브: 하둡에서 동작하는 데이터 웨어하우스 인프라 구조입니다.
   4. 스파크: 디스크 기반의 맵리듀스의 느린 속도를 메모리 기반으로 작업하여 보완하는 인메모리 분석 프레임워크
      1. RDD: 탄력적 분산 데이터 셋. 스파크는 RDD를 기반으로 데이터를 조작한다. 데이터 셋 이외에도 데이터 프레임을 사용할 수도 있다.
      2. 데이터를 Transformation하면 지속적으로 새로운 id가 생긴다. 이 아이디를 바탕으로 실패한 지점 이전 지점부터 작업을 재개한다.
      3. Transformation으로는 맵, 필터, 그룹바이, 조인 등 RDD로부터 RDD를 만드는 작업이다. vs Action 작업은 count, collection, save 등 결과를 리턴하거나 저장소나 HDFS에 쓰는 작업이다.
      4. 어떤 언어를 사용해도 스파크 내부에서 Catalyst Optimizer가 물리적인 실행계획을 관장해서 최적화를 해준다.

4. 플럼: 로그 데이터 수집 기술. 소스, 채널, 싱크로 데이터를 처리한다.
5. 머신러닝, 추천시스템, 데이터 분석 및 통계 지식

## 컴퓨터 공학

### 네트워크

1. http란? 클라이언트와 서버 간의 요청과 응답을 전송하는 TCP/IP 기반의 통신 규약이다.

   1. 특징: 1. 비연결 지향(<-> 쿠키, 세션), 2. 단방향성
   2. 문제점: 도청 가능, 위장 가능, 변조 가능

1. 통신자체를 ssl이라는 다른 프로토콜로 조합함으로써 http의 통신 내용을 암호화할 수 있다. 이를 https라 부른다.

   1. https는 ssl과 통신하고 ssl은 tcp와 통신한다.
   2. 대칭키 암호화 방식과 공개키 암호화 방식을 사용한다.
      1. 대칭키 암호화: 암호화에 사용되는 키와 복호화에 사용되는 키가 동일한 암호화 기법이다. 키를 전달해야 하여 취약하다.
      2. 공개키 암호화: 비대칭키 암호화이다. 개인키로만 복호화할 수 있는 공개키를 공개한다.

1. get vs post

   1. 헤더 vs 바디
   2. 길이가 짧다 vs 길다
   3. 데이터를 가져와서 보여줌 vs 서버의 값이나 상태를 변경 혹은 추가
   4. 캐싱 가능 vs 불가능

1. TCP: 신뢰성 있는 데이터 전송을 지원하는 연결 프로토콜입니다.

   1. 데이터를 패킷 단위로 나누어 같은 목적지로 전송한다.
      1. 패킷: 인터넷 내에서 데이터를 보내기 위한 경로 배정을 효율적으로 하기 위해서 데이터를 나눈 조각
   2. 통신 시작과 해제
      1. 3 way handshake로 연결을 설정하고 통신을 시작한다: 신 -> 신, 액 -> 액
      2. 4 way handshake 과정을 통해 연결을 해제 한다: 핀 -> 액 … 핀 -> 액
   3. 장점: 흐름, 혼잡, 오류 제어로 신뢰성을 보장하고 전송 순서를 보장하고, 수신 여부를 보장한다.
      1. 흐름 제어
         1. stop and wait: 확인 응답을 받아야 다음 패킷을 전송
         2. 슬라이딩 윈도우: 수신 측에서 설정한 윈도우 크기 만큼 송신 층에서 확인 응답 없이 세그먼트를 전송한다.
      2. 오류 제어: 에러 유무에 따라 ack이나 nak을 보낸다.
         1. stop and wait ARQ:
         2. 슬라이딩 윈도우: 확인된 마지막 프레임 이후로 모든 프레임을 재전송 한다.
      3. 혼잡 제어: 혼잡을 피하기 위해 데이터 전송 속도를 제어한다.
         1. 합증가/ 곱 감소 알고리즘: 성공하면 윈도우 사이즈 1씩 증가, 실패시 반으로 줄임
         2. 슬로우 스타트: 임계값 2배씩 증가하다가, 실패 시 1로
   4. 단점: UDP보다 전송 속도가 느리다.
      1. UDP: 데이터를 그램 단위로 나뉘어서 처리하고, 연결 설정 없이 데이터를 전달하는 방식

1. naver.com을 치면 일어나는 일

   1. 사용자가 브라우저에 도메인네임을 입력합니다.
   2. DNS 서버에서 url 주소 중에서 도메인 네임을 검색하여 해당하는 IP 주소를 전달한다.
   3. 페이지 url 정보와 ip 주소를 http 프로토콜을 사용하여 리퀘스트 메시지를 생성하고 tcp 프로토콜을 사용하여 인터넷을 거쳐 해당 ip 주소의 컴퓨터로 전송됩니다.
   4. 전달된 메세지는 http 프로토콜을 사용하여 웹 페이지 url 정보로 변환되어 url 정보에 해당하는 데이터를 검색합니다.
   5. 검색된 웹 페이지 데이터는 또다시 http 프로토콜을 사용하여 레스폰스 메세지를 생성하고, 또다시 tcp 프로토콜을 사용하여 원래 컴퓨터로 전송됩니다.
   6. 도착한 http 응답 메세지는 http 프로토콜을 사용하여 웹 페이지 데이터로 변환되어 웹 브라우저에 의해 출력됩니다.

1. DNS: 도메인 네임과 함께 해당하는 ip 주소를 한 쌍으로 저장하고 있는 데이터베이스가 DNS이다.

   1. ip주소: 컴퓨터들의 인터넷 상에서의 주소 ipv4라고 하여 32비트로 구성되어 있다.
   2. 도메인 네임: 12자리의 ip 주소를 문자로 표현한 것.

1. 쿠키 vs 세션:

   1. 저장위치: 클라이언트 웹 브라우저의 메모리/ 하드디스크 vs 서버의 메모리
   2. 만료시점: 삭제될 날짜 지정 vs 클라이언트 로그아웃 혹은 무반응
   3. 리소스: 클라이언트 자원 vs 서버의 리소스 차지
   4. 용량 제한: 도메인당 20개\*4kb vs 제한 x
   5. 보안: 취약 vs 우수

1. 캐시: 같은 웹 페이지에 접속할 때 사용자의 pc로부터 로드하여 서버를 거치지 않고 페이지를 빠르게 로딩하도록 하는 것. css/js 파일을 로드하는 방식으로 사용한다.

1. 로드밸런싱: 여러 서버에 균등하게 트래픽을 분산시켜주는 것
   1. 트래픽을 감당하기 위하여 여러 서버가 나눠서 일해야 한다.
   2. 라운드 로빈, 리스트 커넥션(부하 적은 서버로), 소스(같은 사용자 같은 서버)

### 운영체제

1. 프로세스: 실행 중인 프로그램으로 코드, 데이터, 스택, 힙을 제공 받는다.
   1. 프로세스 제어 블록: 커널 내의 자료구조로 프로세스 전환이 이루어지면 작업의 진행 상황을 저장한다.
   2. 멀티 프로세스
      1. 장점: 여러 개의 자식 프로세스 중 하나에 문제가 발생하더라도 안전하다
      2. 단점: 서로 공유하는 메모리가 없기 때문에 나타나는 문제, 컨텍스트 스위칭에서의 오버헤드가 일어난다. 캐시 메모리를 비워야 한다.
2. 스레드: 프로세스의 실행 단위. 프로세스 내의 코드, 데이터, 힙 영역은 다른 스레드와 공유하고 스택 영역은 따로 할당받는다.
   1. 멀티 스레드
      1. 장점: 메모리와 자원 소모 감소, 스레드간 통신 시 전역 변수의 공간 또는 동적으로 할당된 힙 영역을 이용해 데이터를 주고 받으므로 통신 방법이 간단하다. 컨텍스트 스위칭에서 캐시 메모리를 비울 필요가 없어서 비용이 적고 빠르다.
      2. 단점: 동기화의 문제가 나타난다.
3. 컨텍스트 스위칭: cpu는 한번에 하나의 프로세스만 처리할 수 있는데, 여러 프로세스를 처리해야 하는 상황에서 현재 진행중인 task의 상태를 프로세스 제어 블록에 저장하고 다음 진행할 값을 읽어 적용하는 과정.
4. 스레드 세이프
   1. 뮤텍스 방식: 공유자원에 들어갈 키를 선점했다가 반납하는 방식
   2. 세마포어 방식: 공유자원에 들어갈 수 있는 수를 기록하는 방식
   3. 임계영역: 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원을 접근하는 코드의 일부.
5. 시스템콜: 사용자 프로그램은 스스로 특권 명령을 수행할 수 없으므로, 운영체제에 특권 명령의 대행을 요청하는데 이러한 요청을 시스템 콜이라고 부른다.
6. 인터럽트: 하드웨어 장치가 cpu에게 어떤 사실을 알려주거나 서비스를 요청해야할 경우 인터럽트를 발생시킨다.
   1. 인터럽트 벡터: 인터럽트 발생시 처리해야할 루틴의 주소를 보관하고 있는 테이블
   2. 인터럽트 핸들러: 실제 인터럽트를 처리하기 위한 루틴
7. 데드락:
   1. 은행원 알고리즘: 시스템이 자원을 할당한 후에도 안정 상태로 남아있게 되는지를 검사하여 교착 상태를 피한다.
8. cpu 스케줄링
   1. 선점형
      1. Shortest Remaining Time
      2. Round Robin
      3. Multi level Queue: 각 그룹에 따라 준비 큐를 여러개 두며 다른 규칙
   2. 비선점형
      1. First Come First Server: 소요 시간 긴 프로세스가 먼저 오면 오래 기다려야 한다.
      2. Shortest Job First: 점유시간을 알 수 없다.
   3. 우선순위형
9. 스케줄러
   1. 장기 스케줄러 : 메모리와 디스크
   2. 단기 스케줄러 : cpu와 메모리
10. 가상 메모리: 보조 기억 장치 공간을 이용해 프로세스의 일부만 메모리에 로드하고 나머지는 보조 기억 장치에 둔다. 이에 실제 메모리 주소가 아니라 가상의 메모리 주소를 주는 것이 가능하다.
11. 페이징: 프로세스의 주소 공간을 동일한 사이즈의 페이지로 나눈다.
    1. 내부 단편화: 마지막 페이지에 한 프레임을 다 채울 수가 없어서 발생하는 공간으로 메모리 낭비의 원인이 된다.
12. 세그멘테이션: 프로세스를 크기가 다른 세그먼트로 분할하는 것.
    1. 외부 단편화: 페이지보다 세그먼트가 커서 할당될 수 없는 문제.

### 데이터베이스

1. 테이블: 행과 열로 이루어진 데이터의 집합입니다.

   - 릴레이션: 관계형 데이터베이스에서의 테이블로, 테이블에 특별한 제약이 추가된 것입니다.
   - 특별한 제약은
     - 모든 값은 유일한 값을 가진다는 제약
     - 하나의 테이블에서 중복되는 행이 존재하면 안된다는 제약입니다.
   - 행은 한 객체에 대한 정보를 가지고 있고 튜플 또는 레코드라는 이름으로 불립니다.
   - 열은 테이블의 속성을 의미하며 같은 도메인으로 되어 있고 어트리뷰트이라고 불립니다.
   - 도메인은 데이터베이스에서 속성들에 채워질 수 있는 값의 집합입니다.

2. 스키마는 데이터베이스의 구조를 기술한 것입니다.

   - 레코드의 크기, 키의 정의, 레코드 간의 관계 등을 정의합니다.
   - 외부스키마, 개념스키마, 내부스키마로 구분합니다.
     - 외부스키마: 사용자 입장에서 정의한 데이터베이스의 논리적 구조입니다. 여러개가 존재할 수 있습니다.
     - 개념스키마: 전체를 관장하는 입장에서 데이터베이스를 정의한 스키마. 모든 논리적 구조를 기술한 것으로 데이터베이스에 하나만 존재합니다.
     - 내부스키마: 데이터베이스가 물리적인 저장 장치에 어떻게 저장될지에 대한 정보입니다.
   - DBMS는 외부스키마에 명세된 사용자의 요구를 개념스키마로 변환하고, 이를 다시 내부 스키마로 변환합니다.

3. 키란? 검색이나 정렬 시 튜플을 구분할 수 있는 기준이 되는 어트리뷰트입니다.

   1. 후보키: 릴레이션에 있는 모든 튜플에 대해서 유일성과 최소성을 만족시키는 속성입니다.
      1. 유일성: 키로 하나의 튜플을 유일하게 식별할 수 있다는 특성입니다.
      2. 최소성: 꼭 필요한 컬럼으로만 구성되었다는 특성입니다.
   2. 기본키(pk): 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성입니다.
      1. 널 값을 가질 수 없고,
      2. 중복 값을 가질 수 없습니다.
   3. 대체키: 후보키가 둘 이상일 때 기본 키를 제외한 나머지 후보키들입니다.
   4. 슈퍼키: 속성들의 집합으로 구성된 키
   5. 외래키: 관계를 가지고 있는 한 테이블이 다른 테이블을 참조할 때, 다른 테이블의 기본키와 대응되는 속성을 가지게 되는데 이를 외래키라고 합니다.
      1. 외래키로 지정되면 참조 테이블의 기본키에 없는 값은 입력할 수 없습니다.

4. SQL 인젝션이란? 해커에 의해 조작된 SQL 쿼리문이 데이터베이스에 그대로 전달되어 비정상적 명령을 실행시키는 것입니다.

   1. 공격방법
      1. 인증우회: 인풋 창에 비밀번호를 입력함과 동시에 다른 쿼리문을 함께 입력하는 것
      2. 데이터노출: 에러 메시지를 발생시켜 데이터베이스의 구조를 유추하고 해킹에 활용한다.
   2. 방어방법
      1. 인풋 값을 받을 때 특수 문자 여부 검사한다.
      2. SQL 서버 오류 발생시에 해당하는 에러 메시지를 감춘다. 예를 들어 View를 활용해 원본 데이터베이스 테이블에는 접근 권한을 높인다. 일반 사용자는 View만 볼 수 있다.
      3. prepare statement로 특수문자를 자동으로 회피한다.

5. 조인이란? 두 개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법입니다.

   1. 이너, 레프트, 라이트, 풀
   2. 크로스(모든 경우의 수), 셀프(하나의 테이블을 여러번 복사해서 조인)

6. SQL vs NoSQL
   1. SQL은 관계형 데이터베이스이다.
      1. 정해진 데이터 스키마에 따라 테이블에 저장된다. 스키마를 수정하지 않는 이상 정해진 구조에 맞는 레코드만 추가가 가능하다.
      2. 관계를 통해 여러 테이블에 분산된다. 관계를 통하여 데이터의 중복을 피합니다.
      3. 관계를 맺고 있는 데이터가 자주 변경되는 경우
      4. 장점: 명확하게 스키마가 정의되어 데이터 무결성을 보장합니다.
      5. 단점: 조인문이 많은 복잡한 쿼리가 만들어질 수 있습니다.
   2. NoSQL은 스키마도 없고 관계도 없는 비관계형 데이터베이스로 레코드를 문서라고 부른다.
      1. 다른 구조의 데이터를 같은 컬렉션에 추가가 가능하다.
      2. 문서는 Json과 비슷한 형태를 가지고 있다. 여러 테이블에 나누어 담지 않고 관련 데이터를 동일한 컬렉션에 넣는다.
      3. 여러 테이블에 조인할 필요 없이 필요한 모든 것을 갖춘 문서를 작성하는 것이 NoSQL입니다.
      4. 따라서 읽기는 자주 하지만 데이터 변경은 자주 없는 경우에 사용
      5. 장점: 스키마가 없어서 유연하고 애플리케이션이 필요로 하는 형식으로 데이터가 저장됩니다.
      6. 단점: 데이터에 중복이 발생한다. 수정시 모든 컬렉션에서 수정해야한다.
7. 어노멀리
   1. 삽입이상: 기본키가 Null값이 될 수 없어서 불필요한 데이터를 추가해야 삽입할 수 있는 상황
   2. 갱신이상: 데이터를 일부만 변경하여 데이터가 불일치하는 모순의 문제
   3. 삭제이상: 튜플 삭제로 인하여 꼭 필요한 데이터까지 함께 삭제되는 문제
8. INDEX란? 관계형 데이터 베이스에서 검색 속도를 높이기 위해 사용하는 하나의 기술입니다.
   1. INDEX를 해당 컬럼에 주게되면 FRM(테이블의 구조), MYD(실제 데이터), MYI(index 정보)를 준다. MYI에 인덱스에 대한 정보가 들어있다.
   2. 사용자가 index를 사용하는 select 쿼리를 사용시에 해당 table을 검색하는 것이 아니라 myi 파일의 내용을 검색한다.
   3. 장점: 키 값을 기초로 하여 테이블에서 검색과 정렬 속도를 향상시킨다.
   4. 단점: 파일의 크기가 늘어난다. 레코드를 추가 또는 삭제할 때 성능이 떨어진다.
   5. select의 속도가 느리다? index 기술을 사용한다.
9. 트랜잭션: 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위
   1. 많은 SQL 명령문들을 사람이 정하는 기준에 따라 나누는 것.
   2. 특징
      1. 원자성: 트랜잭션이 0 혹은 1
      2. 일관성: 처리 결과가 일관성
      3. 독립성: 둘 이상이 병행 실행될 때 다른 연산에 끼어들면 안된다.
      4. 지속성: 영구적으로 반영되어야 한다.
   3. 커밋: 트랜잭션이 성공적으로 끝나서 일관성이 있음을 알려주는 연산. 롤백: 트랜잭션이 비정상적으로 종료되어 원자성이 깨졌을 때 전 상태로 롤백한다.
