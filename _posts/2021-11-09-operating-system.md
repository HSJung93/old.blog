---
title: "운영체제"
date: 2021-11-09T11:07:00+09:00
categories:
  - 메모
tags:
  - 운영체제
header:
  teaser: /assets/images/slipBox.jpg
---

## 캐시 vs 버퍼 vs 레지스터

- 데이터를 임시적으로 저장한다는 공통점

### 캐시

- cpu와 메인 메모리 사이에서 속도 차이에 따른 병목 현상 줄이기
- 자주 사용하는 데이터나 값을 복사해놓는 임시 저장소
- cpu / 레지스터 / l1 / l2 / l3 / 메인 메모리 / 저장 장치
- 프로그램에서 직접적으로 읽거나 쓸 수 없고 하드웨어의 메모리 관리 시스템이 내부적으로 제어한다.
- 데이터 지역성을 이용한 기법. 참고로 명령어는 공간적 지역성이 높고, 데이터는 시간적 지역성이 높다.
- 적중률이란 얼마나 캐시를 통해서 데이터를 잘 찾았는지의 정도이다.
- 캐시는 메모리에 있는 데이터를 임시로 가져온 것이므로 캐시에 있는 데이터가 변경되면 메모리에 있는 데이터를 변경해야 한다.
  - 즉시 쓰기: 캐시에 있는 데이터가 변경되면 이를 즉시 메모리에 반영한다.
  - 지연 쓰기: 변경된 내용을 모아서 주기적으로 반영한다.
- 롱 테일의 법칙: 자주 요구하는 데이터 중 20% 정도 요구한 것이 시스템 리소스의 대부분을 사용한다.

### 버퍼

- 데이터를 한 곳에서 다른 곳으로 전송하는 동안 일시적으로 데이터를 보관하는 메모리 영역
- 사용 후에 데이터를 폐기한다.
- 캐시는 cpu를 보조하고, 버퍼는 저장장치를 보조한다.
- 스풀: 디스크 공간의 일부를 버퍼처럼 사용하는 것

## 레지스터

- cpu가 요청을 처리하는 데이터의 임시저장 공간. cpu는 자체적으로 데이터를 저장할 수 없기 때문에 레지스터를 이용하여 연산처리 및 데이터 주소 지정을 돕는다.
- 종류
  - 프로그램 카운터: 다음 인출될 명령어의 주소를 저장
  - 어큐뮬레이터: 연산 결과 데이터를 일시적으로 저장
  - 인스트럭션 레지스터: 가장 최근에 인출된(실행중인) 명령어를 저장
  - 메모리 어드레스 레지스터: PC에 저장된 명령어 주소가 사용되기 전에 일시적으로 저장되는 주소 레지스터
  - 메모리 버퍼 레지스터: 기억장치에 저장될 데이터 혹은 읽혀진 데이터가 일시적으로 저장되는 버퍼 레지스터

## 시스템 콜

- 시스템 콜: 커널 영역의 기능을 사용자 모드가 사용 가능하게, 프로세스가 하드웨어에 직접 접근해서 필요한 기능을 사용할 수 있게 해준다.
- 프로세스 컨트롤, 파일 매니지먼트, 디방시ㅡ 매니지먼트, 정보 관리, 커뮤니케이션, 보안

## 메모리 할당

### 주소 바인딩

- 주소 바인딩: 프로세스의 논리적 주소를 물리적 메모리 주소로 연결시켜주는 작업
- 컴파일 타임 바인딩: 컴파일을 하는 시점에 해당 프로그램이 물리적 메모리의 몇 번지에 위치할 것인가를 결정한다.
- 로드 타임 바인딩: 프로그램 실행이 시작될 때 물리적 메모리 주소가 결정된다.
- 실행 시간 바인딩: MMU 하드웨어를 사용하여, 프로그램 실행 이후에도 프로그램이 위치한 물리적 메모리 상의 주소가 변경될 수 있다.
- MMU 기법: cpu가 특정 프로세스의 논리적 주소를 참조하려고 할 때, 논리적 주소값에 기준 레지스터의 값을 더해서 물리적 주소값을 얻는다. 논리적 주소값이 한계 레지스터 값을 넘으면 트랩을 발생시켜 해당 프로세스를 강제 종료 시킨다.

### 페이징 vs 세그멘테이션

- 페이징: 크기가 동일한 영역인 페이지로 나누어 처리하는 방법이며 고정 분할 분산 메모리 할당 기법이다. 고정 분할 방식.
- 페이지를 잘게 자를수록 내부 단편화는 줄지만 외부 단편화가 늘어난다.
- 세그멘테이션: 서브루틴, 함수, 프로시져, 모듈 등 논리적 단위가 되는 구조로 페이지를 만드는 것. 가변 분할 방식.
- 컴팩션: 가변 분할 방식에서 외부 조각의 문제를 해결하기 위하여 메모리 영역을 한쪽으로 모은다.

### 동적 메모리 할당 문제

- 최초 적합 방법(First-Fit): 프로그램 크기보다 큰 가용 공간이 최초로 발견될 때 해당 프로세스를 할당한다. 시간적인 측면에서 효율적이다.
- 최적 적합 방법(Best-Fit): 프로그램 크기보다 크지만 가장 작은 가용 공간을 찾고 프로세스를 할당한다. 모든 가용 리스트를 탐색해야 하는 오버헤드가 발생한다.
