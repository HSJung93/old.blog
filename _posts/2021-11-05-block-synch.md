---
title: "Block vs Nonblock - Synch vs Asynch"
date: 2021-11-05T16:25:00+09:00
categories:
  - 메모
tags:
  - block-vs-Non-block
  - synch-vs-asynch
header:
  teaser: /assets/images/slipBox.jpg
---

어플리케이션의 프로세스나 스레드가 커널에게 I/O를 요청하는 하는 상황에 가능한 4가지 상황이다.

# Blocking

- 프로세스(스레드)가 커널에게 I/O를 요청하는 함수를 호출하고 커널이 작업을 완료하면 함수가 작업 결과를 반환한다.
- I/O 작업이 진행 중인 동안 프로세스(스레드)가 자신의 작업을 중단한 채 대기해야한다.
- 여러 클라이언트가 접속하여 I/O 작업을 시도할 경우 작업 중단에 의해 또다른 스레드가 필요로해진다. 결국 CPU의 컨텍스트 스위칭 횟수의 증가로 인하여 비효율이 발생한다.

# Non-Blocking

- I/O 작업을 진행하는 동안 프로세스(스레드) 의 작업을 중단시키지 않는다. 프로세스가 커널에게 I/O를 요청하는 함수를 호출하면, 함수는 I/O를 요청한 다음 진행상황과 상관없이 바로 결과를 반환하기 때문이다.
- 예컨대 최초의 recvfrom 함수를 호출하는 시스템 콜이 일어나면, recvBuffer라는 버퍼 메모리가 비어있다면 "EWOULDBLOCK을 리턴하고 프로세스는 다른 작업을 진행한다. 마침내 recvBuffer가 채워지면 메모리간 복사를 이용해 I/O보다 훨씬 빠른 속도로 데이터를 받아온다.

# 이벤트 통지 모델

- 이벤트 통지 모델은 I/O처리를 할 수 있는 소켓을 가르쳐 주는 방식으로 Non-Blocking 보다 개선을 꾀한다.
- 입력 버퍼에 데이터가 수신 되어 데이터의 수신이 필요한 경우, 출력 버퍼에 데이터가 비어서 데이터의 전송이 가능한 상황을 통지한다.
- 프로세스는 커널에게 I/O 처리를 요청하는 것은 Non-Blocking 방식과 같은데, 이벤트 통지 모델에서는 커널이 프로세스에게 I/O의 상황을 통지한다

# Synchronous

- 동기형 통지 모델에서는 프로세스가 커널에게 지속적/능동적으로 I/O 준비 상황을 체크(Notify)한다.
- 커널은 수동적으로 현재의 상황을 보고한다.
- 기존의 Blocking과 Non-Blocking 모두 Synchronous 방식 이었다.
- Block을 하던 안하던 프로세스의 호출한 함수가 리턴하는 시간과 커널에서 결과를 가져오는 시간이 일치한다.
- Non-Blocking 방식으로 다른 작업을 하더라도 다 처리하면 I/O 작업에서 데이터가 도착했는지 확인한다.

# Asynchronous

- 비동기형 통지 모델에서는 커널이 프로세스에게 I/O의 준비상황을 통지(Notify)한다.
- 프로세스는 수동적으로 자신의 작업을 하며 통지를 기다린다.
- I/O 작업에서 데이터가 도착했는지 확인하지 않고 다른 작업을 처리한다.
- Asynchronous Blocking 조합은 비효율적이라 직접적으로 사용하는 모델은 없다. Node.js에서 MySQL를 함께 사용하는 경우, AN 모델 중에서 의도와 다르게 AB로 동작할 때가 있다.

# 개념 비교

- Blocking vs Non-Blocking
  - I/O 나 멀티스레드 동기화 등 직접 제어할 수 없는 대상을 어떤 방식으로 처리할지
  - 직접 제어할 수 없는 대상의 작업이 끝날때 까지 제어권을 넘겨주는 것을 막거나, 막지 않는다.
- Synchronous vs Asynchronous
  - 두 함수나 어플리케이션이 시간을 맞출 것인지 = 지속적으로 호출된 함수에게 확인 요청을 할 것인지.
- 발전 과정:
  - SB
  - SN
  - AN
