---
title: "카카오톡의 서버 사이드 코틀린"
date: 2022-01-23T23:28:00+09:00
categories:
  - 메모
tags:
  - Kakao
  - Java
  - Kotlin
# header:
#   teaser: /assets/images/code.jpg
---

카카오톡에서 코틀린으로 서버를 구성하게 된 계기와 코틀린 도입에 대한 이야기가 너무 재미있어 공유합니다. 코틀린으로 돌아가는 서버는 점점 늘어갈 것 같습니다. Java 서버 개발은 언어 지식뿐 아니라 프레임워크 지식이 중요한데 그대로 적용할 수 있기 때문에 금방 습득할 수 있다. 또한 동기 부여가 되기도 한다. 

https://tv.kakao.com/channel/3150758/cliplink/391419295

## 카카오 서비스 구성

카카오의 평소 peek는 초당 80만 정도이다. 최대는 650만 정도를 처리한 적이 있다.

카카오의 서비스는 LOCO와 WEBAPP으로 구성된다. LOCO에는 메시지 전송, 채팅방, 미디어 전송 기능이 구현되고, WEBAPP에는 가입, 인증, 친구, 프로필, 설정, 톡검색 기능 등이 구현된다.

LOCO는 20011년 "겁나 빠른 황소 프로젝트"에서 카카오에서 개발해낸 TCP/IP 바탕으로 작동하는 새로운 HTTP Request/Response 프로토콜이다. 패킷 사이즈 경량화, 푸시 시스템 구조 최적화, 백엔드 시스템 성능 개선이 특징이다. 이후 2018년까지 7년간 중단도 없고 점검도 없었다.

2017년부터 Brewery라는 카카오톡 서버 구조 개선 프로젝트를 시작하고 개발 언어로 코틀린을 도입하였다.

## 코틀린(for JVM) 선택의 배경

코틀린을 선택한 배경은 적정한 성능/안정성, 개발/운영의 편의성, 다양한 목적의 서버 환경에 검증된 자바의 생태계를 이용, 생산성이 좋은 새로운 언어, 적정 수준의 러닝 커브 등이 있었다. 

### 개발 환경

개발 환경, 생태계, 문법, 잘 돌아가는지 여부를 도입을 고민할 때 걱정을 할 것이다. 개발환경은 안정화 되어 있다. 개발 환경 부분에 있어서는 자바 코드를 복사해서 코틀린에 붙여 넣으면 코드가 변환이 될 정도로 IntelliJ가 강력하다. 

생태계는 자바와 완전한 호환으로 생태계를 공유하며 프레임워크의 러닝 커브가 없다. 자바와 코틀린간 인터페이스, 클래스, 선언 및 메소드 호출까지도 호환이 될 정도로 호환성이 코틀린은 자바 솔루션에 대한 연동성이 높다. 언어에 대한 러닝커브는 있을 지언정 프레임에 대한 러닝커브는 없다. data class를 보면 문법적인 측면에서 매우 적게 적어도 된다. 코틀린은 자바보다도 정적으로 타입의 변환을 체크한다(int에서 Integer 오토 박싱하지 않는다).

### 문법
문법은 하위 호환할 레거시 문법이 없다.Nullable을 문법에서 구분한다. 자바의 Optional이 강제된 것. Nothing은 어떠한 값도 포함하지 않는 타입으로 인스턴스를 생성할 수 없다. 종료되지 않거나 Exception을 throw하는 경우 사용한다. 타입이 완결되었다. nullable을 구분하여 segmentation fault 문제를 방지한다는 것이 혁신적이다. null 일수 있는 객체의 필드에 접근하면 null pointer exception이 발생할 수 있으므로 컴파일 타임에 오류가 발생한다. 받는 타입도 nullable로 정의하거나 엘비스 연산자로 값을 처리해야한다. 혹은 smart cast로 null값을 if문으로 체크해도 된다. 자바 코드에서 값을 받아올 때에 주요하게 체크를 하는 지점이 된다. 

> segmentation fault - 허용되지 않은 방법으로 메모리에 접근할 때 발생하는 에러

effective java에서는 불변 클래스가 성능도 좋고 안전하기에 사용하기를 권장한다. 대부분의 언어는 스트링이 불변 클래스이다. 만약 스트링이 가변이면 어떤 일이 발생할까? 로그를 찍을 때 스트링을 보냈는데 중간에 바뀌어 버리면 로그가 잘못 찍힌다던지, 맵에 키를 이용한 스트링을 넣었는데 그값이 바뀌면 키가 바뀐다는지 문제가 생긴다. 바뀌는 이벤트를 받아서 처리하거나, 락을 걸어서 바뀌지 않는 부분을 확인해야하는데 코드가 복잡 성능도 문제가 생긴다. 코틀린의 이뮤터블 리스트는 자바의 이뮤터블 리스트가 런타임이 아니라 컴파일 타임에 막는다. 

디폴트로 상속이 불가능하고 반대로 open을 사용해야 한다. 통제되지 않은 상속에서 오는 문제가 있다. 라이브러리를 이상하게 상속을 받아서 사용할 때의 문제. 단 Spring은 AOP를 위해서 상속이 필요해서 거슬리는 부분이 있다. 컴파일러 플러그인에 스프링에 관련된 여러 클래스는 open을 자동적으로 붙여서 컴파일 되도록 하는 플러그인이 있어서 이를 이용하면 좋다. 

스트링이 null인지 아닌지를 알기 위해서 유틸을 사용하지 않고 바로 그 객체에 대해서 사용할 수 있다. 리시버, 헬퍼 펑션 없이 확장 함수를 사용한다. 알아서 타입을 유추하고 가드 처리도 해준다. 그래서 임시 변수를 만들 필요가 없다. 선언형 문장으로 임시 변수를 만들 필요가 없다. 

람다 파라미터의 경우 ()를 생략할 수 있다. 이는 DSL로 이용하기 좋은 문법이다. stream()과 list 변환을 하지 않아도 된다. 

로거 팩토리를 만들고 생성했을 때, 추가적으로 실행할 코드를 하나 덧붙이거나 전체 값을 바꿀 때 유용하다. 

무엇보다 비동기 로직을 처리할 때 코루틴만한 것이 없다. 

## 잘 돌아가는가?

Vert.x, gRPC-java 위에 RxJava2 Guice를 올린 Service가 안정적으로 대량의 트래픽을 처리하고 있다. 

### 마이그레이션 주의 사항
* 자바 코드/ 클래스 연동시 타입 변환을 주의 해야 한다. (Nullable 등)
* Lombok 적용된 자바 코드와는 같은 모듈에 사용하기 힘들다. delombok 사용하자.
* Spring에서는 특정 클래스/ 함수를 open 해줘야 한다. kotlin-spring 플러그인을 사용하자.
* Immutable 데이터로 리팩토링 하는 것은 생각보다 어렵다. Immutable로 안한 프로젝트를 리팩토링하는 것은 생각보다 큰 일이다. 

## 따라서
새로운 프로젝트는 처음부터 코틀린으로 하는 것이 좋으며, 수정이 앞으로도 많은 프로젝트는 모델, 유틸리티부터 리팩토링 하는 것이 좋다. 잘 돌아가고 있는 자바 프로젝트는 잘 돌아가게 두면 된다. 